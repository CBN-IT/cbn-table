<!--
An infinite table component based on `iron-list`.

Example:
```
    <cbn-data-table style="height: 500px;" items="[[items]]" columns="[[columns]]">
    </cbn-table>
```

**Note**: like `iron-list`, the element needs to be explicitly sized!

See [docs/data-table.md](data table documentation) for a detailed usage description.

<br />
### Styling

See `cbn-table` for information about styling the element.

@group CBN Elements
@element cbn-data-table
@demo demo/index.html
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-input/iron-input.html">

<link rel="import" href="lib/include.html" />
<link rel="import" href="cbn-table.html" />

<dom-module id="cbn-data-table">
	<template>
		<style>
			:host {
				display: block;
				position: relative;
			}
			#table {
				position: absolute;
				top: 0; left: 0;
				bottom: 0; right: 0;
				z-index: 1;
			}
		</style>
		
		<content select=".before"></content>
		
		<cbn-table id="table" items="{{_filteredItems}}">
			<template class="cbn-table-header">
				<div class="cbn-table-row">
					<template is="dom-repeat" items="{{_columns}}" as="column" index-as="column_index">
						<div class="cbn-table-cell cbn-table-column">
							<div class$="[[_computeColumnCaptionClasses(column.obj, sortOrdering.*, sortable)]]"
								on-tap="_columnClicked" style$="[[_computeCellStyles(column.obj.headStyle, column.obj)]]">[[column.obj.caption]]</div>
							
							<template is="dom-if" if="[[_computeIsFilterable(column.obj.filter, filterable)]]">
								<cbn-data-table-filter column="[[column.obj]]" template="[[column.filterTemplate]]"
													   filter-value="{{column.currentFilter}}">
								</cbn-data-table-filter>
							</template>
						</div>
					</template>
				</div>
			</template>
		</cbn-table>
		
		<template id="itemTemplate">
			<div class="cbn-table-row">
				<template is="dom-repeat" items="[[_columns]]" 
						  as="column" index-as="column_index">
					<div class="cbn-table-cell">
						<cbn-data-table-cell parent-table="[[_self]]" item="[[item]]" column="[[column.obj]]" 
											 style$="[[_computeCellStyles(column.obj.style, item, column.obj)]]"
											 template="[[column.template]]" index="[[index]]"></cbn-data-table-cell>
					</div>
				</template>
			</div>
		</template>
		
		<content></content>
	</template>

</dom-module>

<script>
	(function () {
		
		//noinspection JSUnusedGlobalSymbols
		CbnTable.DataTable = Polymer({
			is: 'cbn-data-table',
			
			properties: {
				
				/**
				 * An array with the table rows to display.
				 */
				items: {
					type: Array,
					value: function() { return []; }
				},
				
				/**
				 * An array with the table's columns.
				 */
				columns: {
					type: Array,
					value: function() { return []; },
					observer: '_columnsChanged'
				},
				
				/**
				 * Whether table filtering is enabled. Defaults to true.
				 */
				filterable: {
					type: Boolean,
					value: true
				},
				
				/**
				 * Whether table sorting is enabled. Defaults to true.
				 */
				sortable: {
					type: Boolean,
					value: true
				},
				
				/**
				 * Stores the currently enabled data filters (map with the column's name + filtered value).
				 * You can also modify this externally to apply custom filtering.
				 */
				dataFilters: {
					type: Object,
					value: function() { return {}; }
				},
				
				/**
				 * Stores the current column ordering.
				 * 
				 * The array contains simple objects that define the column's name (using the `name` property) and its sorting 
				 * direction (the `dir` property, which can be true for ascending, false for descending).
				 */
				sortOrdering: {
					type: Array,
					value: function() { return []; }
				},
				
				/**
				 * If set, the table row template will be optimized.
				 * 
				 * WARNING: experimental, do not use!
				 */
				optimizeTemplate: {
					type: Boolean,
					value: false
				},
				
				// Private properties
				
				/**
				 * Whether the table's light DOM is ready.
				 */
				_isDomReady: {
					type: Boolean,
					value: false
				},
				
				/**
				 * Self-reference to the element, for use in data bindings. 
				 */
				_self: {
					type: Object,
					value: function() { return this; }
				}
				
			},
			
			behaviors: [
				Polymer.Templatizer,
				CbnTable.DataProcessingBehavior
			],
			
			/**
			 * Stores the cell templates that needs to be resolved when the element is attached to the document.
			 */
			_pendingTemplates: [],
			
			// Element Lifecycle
			
			ready: function () {
			},
			
			attached: function() {
				this.async(function () {
					this._isDomReady = true;
					this._pendingTemplates.forEach(function(colDesc) {
						this._resolveColumnElements(colDesc);
					}, this);
					this._pendingTemplates = [];
				});
			},
			
			/**
			 * Called when the `columns` property is changed.
			 */
			_columnsChanged: function() {
				if (!this.columns) return;
				
				this._processColumns(this.columns);
				
				// resolve template references
				this._pendingTemplates = [];
				for (var i=0; i<this._columns.length; i++) {
					this._columns[i].filterTemplate = null;
					this._columns[i].template = null;
					
					if (this._isDomReady) {
						this._resolveColumnElements(this._columns[i]);
					} else {
						this._pendingTemplates.push(this._columns[i]);
					}
				}
				
				this._initItemTemplate();
			},
			
			/**
			 * Resolves the external elements for a table column (if used). 
			 * To be called only after the element is attached (so its light dom is accessible).
			 * 
			 * @param {Object} colDesc The column descriptor object.
			 */
			_resolveColumnElements: function(colDesc) {
				// 1. Column template
				if (colDesc.obj.renderAs == 'template') {
					this.set('_columns.' + colDesc.obj._index + '.template', 
						this._resolveElementSelector(colDesc.obj.template));
				}
				
				// 2. Filter template
				if (colDesc.obj.filterElement) {
					this.set('_columns.' + colDesc.obj._index + '.filterTemplate', 
						this._resolveElementSelector(colDesc.obj.filterElement));
				}
			},
			
			/**
			 * Resolves a string selector, first searching inside the table's local DOM, then among the document root.
			 * 
			 * @param {*} selector The selector of the element to resolve.
			 * @return {Element|null} The DOM element, if found; null otherwise.
			 */
			_resolveElementSelector: function(selector) {
				if (typeof selector === 'string') {
					var template = Polymer.dom(this).querySelector(selector);
					if (!template) {
						template = document.querySelector(selector);
					}
					return (template ? template : null);
				} // else: already a DOM object, return it
				return selector;
			},
			
			/**
			 * Initializes the element's item template.
			 */
			_initItemTemplate: function() {
				// cleanup
				var existing = Polymer.dom(this.$.table).querySelector('template.item-template');
				if (existing) {
					existing.parentNode.removeChild(existing);
				}
				
				if (this.optimizeTemplate) {
					// [re]generate the item template
					this.$.table._itemTemplate = this._generateOptimizedItemTemplate();
					
				} else {
					//noinspection JSUnresolvedVariable
					this.$.table._itemTemplate = this.$.itemTemplate;
				}
			},
			
			/**
			 * Generates an optimized table row template (to minimize rendering overhead).
			 * 
			 * @return {Element} The generated template.
			 */
			_generateOptimizedItemTemplate: function() {
				var tpl = document.createElement('template');
				tpl.classList.add('item-template');
				var content = '<div class="cbn-table-row">';
				this._columns.forEach(function(column, idx) {
					content += '<div class="cbn-table-cell">' +
						'	<cbn-data-table-cell parent-table="[[_self]]" item="[[item]]" column="[[_columns.' +idx+ '.obj]]"' +
								 'style$="[[_computeCellStyles(_columns.' +idx+ '.obj.style, item, _columns.' +idx+ '.obj)]]"' +
								 'template="[[_columns.' +idx+ '.template]]" index="[[index]]"></cbn-data-table-cell>' +
						'</div>';
				});
				content += '</div>';
				tpl.innerHTML = content;
				
				// Initialize the template's annotations (see Polymer/standard/annotations.html)
				Polymer.dom(this.root).appendChild(tpl);
				Polymer.dom.flush();
				
				var notes = [];
				Polymer.Annotations.prepElement = this._prepElement.bind(this);
				Polymer.Annotations._parseTemplate(tpl, Array.prototype.indexOf.call(this.root._lightChildren, tpl), 
					notes, { bindings: [], events: [] } // root parent
				);
				Polymer.Annotations.prepElement = null;
				
				var noteOffset = this._notes.length;
				Array.prototype.push.apply(this._notes, notes);
				this._processAnnotations(notes);
				
				notes.forEach(function(note, idx) {
					idx = idx + noteOffset;
					// marshal nodes
					if (note.templateContent) {
						this._nodes[idx] = tpl;
						this._nodes[idx]._content = note.templateContent;
					}
				}, this);
				
				return tpl;
			},
			
			// Event handlers:
			
			/**
			 * Called when a column is clicked (to re-sort the data).
			 * 
			 * @param {Object} event The Polymer-augumented event object.
			 */
			_columnClicked: function(event) {
				if (!event.model.column.obj.sortable) 
					return;
				var ctrl = event.detail.sourceEvent.ctrlKey;
				this.toggleOrdering(event.model.column.obj.name, ctrl);
			},
			
			/**
			 * Utility method that can be used to generate a custom event from another event.
			 * 
			 * @param {Object} event The original Polymer event object.
			 */
			_throwEvent: function(event) {
				var name = event.currentTarget.getAttribute("data-event");
				if (!name) {
					console.warn("Please specify a `data-event` attribute!");
					return;
				}
				this.fire(name, {
					originalEvent: event,
					item: event.model.item
				});
			},
			
			// UI computation methods:
			
			/**
			 * Computes the classes of column captions.
			 * 
			 * @param {Object} column The column object.
			 */
			_computeColumnCaptionClasses: function(column) {
				var addClass = '';
				if (this.sortable && column.sortable) {
					addClass = 'cbn-table-column-sortable';
					this.sortOrdering.some(function(ordering) {
						if (ordering.name == column.name) {
							if (ordering.dir) {
								addClass = 'cbn-table-column-sort-asc';
							} else {
								addClass = 'cbn-table-column-sort-desc';
							}
							return true;
						}
						return false;
					});
				}
				
				// check whether sorting is enabled for the current column
				return "cbn-table cell-contents " + addClass;
			},
			
			/**
			 * Returns whether a table column is filterable.
			 */
			_computeIsFilterable: function(columnFilterable, filterable) {
				return columnFilterable && filterable;
			},
			
			/**
			 * Computes the styles to show for a table cell / header element.
			 * 
			 * @param {String|Object|Function} styles The style object to compute.
			 * @return {String} The computed CSS string.
			 */
			_computeCellStyles: function(styles) {
				if (typeof styles === 'string') {
					return styles;
					
				} else if (typeof styles === 'function') {
					// the user callback function will compute the actual styles
					var res = styles.apply(this, Array.prototype.slice.call(arguments, 1));
					return this._computeCellStyles(res);
					
				} else if (styles && typeof styles === 'object') {
					var strStyles = '';
					Object.getOwnPropertyNames(styles).forEach(function (n) {
						var cssName = n;
						if (cssName.indexOf('-') === -1) {
							// convert to dash case
							cssName = Polymer.CaseMap.camelToDashCase(cssName);
						}
						strStyles += cssName + ': ' + styles[n] + ';';
					});
					
					return strStyles;
				}
				
				return '';
			}
			
		});
		
	})();
</script>
