<!--
An infinite table component based on `iron-list`.

Example:
```
    <cbn-data-table style="height: 500px;" items="[[items]]" columns="[[columns]]">
    </cbn-table>
```

**Note**: like `iron-list`, the element needs to be explicitly sized!

<br />
### Styling

See `cbn-table` for information about styling the element.

@group CBN Elements
@element cbn-data-table
@demo demo/index.html
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="cbn-table.html" />

<dom-module id="cbn-data-table">
	<template>
		<style>
			:host {
				display: block;
				position: relative;
			}
			#table {
				position: absolute;
				top: 0; left: 0;
				bottom: 0; right: 0;
				z-index: 1;
			}
		</style>
		
		<content select=".before"></content>
		
		<cbn-table id="table" items="[[items]]">
			<template class="cbn-table-header">
				<div class="cbn-table-row">
					<template is="dom-repeat" items="[[_columns]]"
							  as="column" index-as="column_index">
						<div class="cbn-table-cell">
							<span class="cell-contents">[[column.obj.caption]]</span>
						</div>
					</template>
				</div>
			</template>
		</cbn-table>
		
		<template id="itemTemplate">
			<div class="cbn-table-row">
				<template is="dom-repeat" items="[[_columns]]" 
						  as="column" index-as="column_index">
					<div class="cbn-table-cell">
						<cbn-data-table-cell column="[[column.obj]]" template="[[column.template]]" item="[[item]]" 
											 index="[[column_index]]"></cbn-data-table-cell>
					</div>
				</template>
			</div>
		</template>
		
		<content></content>
	</template>

</dom-module>

<script>
	(function () {
		
		Polymer({
			is: 'cbn-data-table',
			
			properties: {
				
				/**
				 * An array with the table rows to display.
				 */
				items: {
					type: Array,
					value: function() { return []; }
				},
				
				/**
				 * An array with the table's columns.
				 */
				columns: {
					type: Array,
					value: function() { return []; },
					observer: '_columnsChanged'
				},
				
				/**
				 * If set, the table row template will be optimized.
				 */
				optimizeTemplate: {
					type: Boolean,
					value: true
				},
				
				// Private properties
				
				/**
				 * The internal representation of the columns.
				 */
				_columns: {
					type: Array,
					value: function() { return []; }
				},
				
				/**
				 * Whether the table's light DOM is ready.
				 */
				_isDomReady: {
					type: Boolean,
					value: false
				}
				
			},
			
			behaviors: [
				Polymer.Templatizer
			],
			
			/**
			 * Stores the cell templates that needs to be resolved when the element is attached to the document.
			 */
			_pendingTemplates: [],
			
			// Element Lifecycle
			
			ready: function () {
			},
			
			attached: function() {
				this.async(function () {
					this._isDomReady = true;
					this._pendingTemplates.forEach(function(colDesc) {
						this._findColumnTemplate(colDesc);
					}, this);
					this._pendingTemplates = [];
				});
			},
			
			/**
			 * Called when the `columns` property is changed.
			 */
			_columnsChanged: function() {
				if (!this.columns) return;
				
				this.set('_columns', []);
				this._pendingTemplates = [];
				
				for (var i=0; i<this.columns.length; i++) {
					var colDesc = {
						index: i,
						obj: this.columns[i]
					};
					this.push('_columns', colDesc);
					
					if (this.columns[i].type == 'template') {
						if (this._isDomReady) {
							this._findColumnTemplate(colDesc);
						} else {
							this._pendingTemplates.push(colDesc);
						}
					}
				}
				
				this._initItemTemplate();
			},
			
			
			/**
			 * Fills the content template of a table column. 
			 * To be called only after the element is attached (so its light dom is accessible).
			 * 
			 * @param {Object} colDesc The column descriptor object.
			 */
			_findColumnTemplate: function(colDesc) {
				var template = Polymer.dom(this).querySelector(colDesc.obj.template);
				if (template) {
					this.set('_columns.' + colDesc.index + '.template', template);
				}
			},
			
			/**
			 * Initializes the element's item template.
			 */
			_initItemTemplate: function() {
				// cleanup
				var existing = Polymer.dom(this.$.table).querySelector('template.template-container');
				if (existing) {
					existing.parentNode.removeChild(existing);
				}
				
				if (this.optimizeTemplate) {
					// [re]generate the item template
					this.$.table._itemTemplate = this._generateOptimizedItemTemplate();
					
				} else {
					//noinspection JSUnresolvedVariable
					this.$.table._itemTemplate = this.$.itemTemplate;
				}
			},
			
			/**
			 * Generates an optimized table row template (to minimize rendering overhead).
			 * 
			 * @return {Element} The generated template.
			 */
			_generateOptimizedItemTemplate: function() {
				var tpl = document.createElement('template');
				tpl.classList.add('item-template');
				var content = '<div class="cbn-table-row">';
				this._columns.forEach(function(column, idx) {
					content += '<div class="cbn-table-cell">' +
							'	<cbn-data-table-cell column="[[_columns.' +idx+ '.obj]]" template="[[_columns.' +idx+ '.template]]" ' +
							'		item="[[item]]" index="' + idx + '"></cbn-data-table-cell>' +
							'</div>';
				});
				content += '</div>';
				tpl.innerHTML = content;
				
				// Initialize the template's annotations (see Polymer/standard/annotations.html)
				Polymer.dom(this.root).appendChild(tpl);
				Polymer.dom.flush();
				
				var notes = [];
				Polymer.Annotations.prepElement = this._prepElement.bind(this);
				Polymer.Annotations._parseTemplate(tpl, Array.prototype.indexOf.call(this.root._lightChildren, tpl), 
					notes, { bindings: [], events: [] } // root parent
				);
				Polymer.Annotations.prepElement = null;
				
				var noteOffset = this._notes.length;
				Array.prototype.push.apply(this._notes, notes);
				this._processAnnotations(notes);
				
				notes.forEach(function(note, idx) {
					idx = idx + noteOffset;
					// marshall nodes
					if (note.templateContent) {
						this._nodes[idx] = tpl;
						this._nodes[idx]._content = note.templateContent;
					}
				}, this);
				
				return tpl;
			}
			
			// UI / computation methods
			
		});
		
		/**
		 * A separate element used for rendering table cell contents (with configurable types and styles).
		 */
		Polymer({
			is: 'cbn-data-table-cell', 
			
			properties: {
				
				/**
				 * The type of the cell's contents.
				 * 
				 * Pre-defined types: 
				 * - 'text': renders the content as plain text;
				 * - 'html': uses `innerHTML` to set the cell's contents as HTML; unsecure, use with care!
				 * - 'template': the content is a model object for a Polymer template (secure alternative for html).
				 */
				type: {
					type: String,
					value: ''
				},
				
				/**
				 * The column's object.
				 */
				column: {
					type: Object,
					observer: '_initContents'
				},
				
				/**
				 * The current item object.
				 */
				item: {
					type: Object
				},
				
				/**
				 * The resolved template element associated with the current column.
				 */
				template: {
					type: Object,
					observer: '_initContents'
				},
				
				/**
				 * The numerical column index of the current cell.
				 */
				index: {
					type: String,
					value: ''
				},
				
				/**
				 * Whether the item is ready.
				 */
				_isReady: {
					type: Boolean,
					value: false
				},
				
				/**
				 * Stores the cell's template instance.
				 */
				_instance: {
					type: Object
				}
				
			},
			
			observers: [
				"_updateContents(item.*)"
			],
			
			behaviors: [
				Polymer.Templatizer
			],
			
			ready: function() {
				this.style.display = 'block';
				this._isReady = true;
				this._initContents();
			},
			
			/**
			 * [Re]Initializes this cell when its column descriptor changes.
			 */
			_initContents: function() {
				if (!this._isReady) return;
				Polymer.dom(this.root).innerHTML = '';
				if (!this.column) return;
				
				if (!this.type) {
					this.type = this.column.type;
				}
				
				switch (this.type) {
					case 'template':
						if (!this.template) return;
						this.templatize(this.template);
						this._instance = this.stamp({ item: this.item });
						Polymer.dom(this.root).appendChild(this._instance.root);
						break;
				}
				
				this._updateContents();
			},
			
			/**
			 * Updates this cell's contents.
			 */
			_updateContents: function(changes) {
				if (!this._isReady) return;
				if (!this.column || !this.item) return;
				
				switch (this.type) {
					case 'text':
						Polymer.dom(this.root).textContent = this._contents;
						break;
					case 'html':
						Polymer.dom(this.root).innerHTML = this._contents;
						break;
					case 'template':
						if (!this._instance) return;
						this._instance.item = this.item;
						break;
				}
			},
			
			/**
			 * Returns the current cell's contents.
			 * @return {String} The value of the current cell.
			 */
			get _contents() {
				return this.item[this.column.name];
			}
			
		});
		
	})();
</script>
